Паттерны проектирования — это **типичные, проверенные способы решения часто встречающихся проблем** при проектировании программного обеспечения. Они представляют собой шаблоны, которые помогают создавать гибкие, масштабируемые и поддерживаемые системы, минимизируя ошибки и избыточность.

- **Цель**: Упростить проектирование, улучшить читаемость кода и обеспечить его повторное использование.
- **Не являются**: Готовыми кусками кода, а скорее концептуальными решениями, которые адаптируются под конкретные задачи.

#### Классификация

Паттерны проектирования делятся на три основные категории в зависимости от их назначения:

### a. Порождающие (Creational)

**Описание**: Решают задачи, связанные с гибким и эффективным созданием объектов, минимизируя зависимости и упрощая процесс инициализации.  
**Цель**: Изолировать процесс создания объектов от их использования.

**Примеры**:

- **[[Singleton]]**: Гарантирует существование единственного экземпляра класса.
- **Factory Method**: Определяет интерфейс для создания объектов, позволяя подклассам решать, какой класс создавать.
- **Abstract Factory**: Создает семейства связанных объектов без указания их конкретных классов.
- **Builder**: Позволяет пошагово конструировать сложные объекты.
- **Prototype**: Создает новые объекты путем копирования прототипа.

### b. Структурные (Structural)

**Описание**: Описывают способы организации объектов и классов для формирования более крупных структур, сохраняя гибкость и эффективность.  
**Цель**: Упростить взаимодействие между объектами и обеспечить их совместимость.

**Примеры**:

- **Adapter**: Позволяет объектам с несовместимыми интерфейсами работать вместе.
- **Bridge**: Разделяет абстракцию и реализацию, позволяя изменять их независимо.
- **Composite**: Позволяет работать с группами объектов как с единым объектом.
- **Decorator**: Динамически добавляет новые обязанности объекту.
- **Facade**: Предоставляет упрощенный интерфейс к сложной подсистеме.
- **Proxy**: Контролирует доступ к объекту, добавляя дополнительную логику.
- **Mediator**: Упрощает взаимодействие между объектами, централизуя их коммуникацию.

### c. Поведенческие (Behavioral)

**Описание**: Решают задачи эффективной коммуникации и распределения обязанностей между объектами.  
**Цель**: Обеспечить гибкое и слабо связанное взаимодействие.

**Примеры**:

- **Observer**: Определяет зависимость "один ко многим", чтобы при изменении одного объекта автоматически обновлялись связанные объекты.
- **State**: Позволяет объекту изменять поведение в зависимости от его состояния.
- **Strategy**: Определяет семейство алгоритмов и делает их взаимозаменяемыми.
- **Command**: Инкапсулирует запрос в виде объекта, позволяя передавать его как параметр.
- **Iterator**: Обеспечивает последовательный доступ к элементам коллекции без раскрытия ее внутренней структуры.
- **Interpreter**: Определяет представление грамматики и интерпретатор для языка.