SOLID — это акроним, обозначающий пять принципов объектно-ориентированного проектирования, которые помогают создавать гибкий, масштабируемый и поддерживаемый код.
1. `S — Single Responsibility Principle (Принцип единственной ответственности)
	**Суть**: Каждый класс, модуль или функция должен отвечать только за одну задачу. Это упрощает понимание, тестирование и поддержку кода.
	**Почему важно**: Если класс делает слишком много (например, обрабатывает данные и рендерит UI), его сложно модифицировать, тестировать или переиспользовать.
	**Применение**: Разделяйте логику (например, работа с API, обработка данных, рендеринг) на отдельные классы или функции. Слайсы в rtk, разделение валидации и отправки форм
	
2. `O — Open/Closed Principle (Принцип открытости/закрытости)`
	**Суть**: Классы должны быть открыты для расширения (добавления новой функциональности), но закрыты для модификации (изменения исходного кода).
	**Почему важно**: Изменение существующего кода может привести к ошибкам, особенно в больших проектах. Расширение через наследование или плагины позволяет добавлять функциональность безопасно.
	**Применение**: Используйте наследование, интерфейсы или паттерны (например, Strategy) для добавления новой функциональности без изменения старого кода.
3. `L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)`
	**Суть**: Объекты дочернего класса должны быть взаимозаменяемы с объектами родительского класса без нарушения работы программы.
	**Почему важно**: Если подкласс нарушает поведение родительского класса, это может привести к неожиданным ошибкам
	**Применение**: Убедитесь, что подклассы реализуют методы родителя так, чтобы их можно было использовать в том же контексте..
4. `I — Interface Segregation Principle (Принцип разделения интерфейсов)`
	**Суть**: Пользователи  не должны зависеть от интерфейсов, которые они не используют. Лучше иметь несколько узкоспециализированных интерфейсов, чем один универсальный.
	**Почему важно**: Если класс реализует ненужные методы, это усложняет код и может привести к ошибкам.
	**Применение**: Разделяйте функциональность на небольшие модули или классы, чтобы избежать ненужных зависимостей.
5. `D — Dependency Inversion Principle (Принцип инверсии зависимостей)`
	**Суть**: Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций (например, интерфейсов). Абстракции не должны зависеть от деталей реализации.
	**Почему важно**: Это снижает связанность и упрощает замену компонентов (например, замену базы данных без изменения бизнес-логики).
	**Применение**: Используйте Dependency Injection (внедрение зависимостей) или абстрактные классы для связи компонентов.