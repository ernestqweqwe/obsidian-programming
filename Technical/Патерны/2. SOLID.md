SOLID — это акроним, обозначающий пять принципов объектно-ориентированного проектирования, которые помогают создавать гибкий, масштабируемый и поддерживаемый код.
1. `S — Single Responsibility Principle (Принцип единственной ответственности)
	**Суть**: Каждый класс, модуль или функция должен отвечать только за одну задачу. Это упрощает понимание, тестирование и поддержку кода.
	**Почему важно**: Если класс делает слишком много (например, обрабатывает данные и рендерит UI), его сложно модифицировать, тестировать или переиспользовать.
	**Применение**: Разделяйте логику (например, работа с API, обработка данных, рендеринг) на отдельные классы или функции. Слайсы в rtk, разделение валидации и отправки форм
	
2. `O — Open/Closed Principle (Принцип открытости/закрытости)`
	**Суть**: Классы должны быть открыты для расширения (добавления новой функциональности), но закрыты для модификации (изменения исходного кода).
	**Почему важно**: Изменение существующего кода может привести к ошибкам, особенно в больших проектах. Расширение через наследование или плагины позволяет добавлять функциональность безопасно.
	**Применение**: Используйте наследование, интерфейсы или паттерны (например, Strategy) для добавления новой функциональности без изменения старого кода.
3. `L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)`
	**Суть**: Объекты дочернего класса должны быть взаимозаменяемы с объектами родительского класса без нарушения работы программы.
	**Почему важно**: Если подкласс нарушает поведение родительского класса, это может привести к неожиданным ошибкам
	**Применение**: Убедитесь, что подклассы реализуют методы родителя так, чтобы их можно было использовать в том же контексте..
4. `I — Interface Segregation Principle (Принцип разделения интерфейсов)`
	**Суть**: Пользователи  не должны зависеть от интерфейсов, которые они не используют. Лучше иметь несколько узкоспециализированных интерфейсов, чем один универсальный.
	**Почему важно**: Если класс реализует ненужные методы, это усложняет код и может привести к ошибкам.
	**Применение**: Разделяйте функциональность на небольшие модули или классы, чтобы избежать ненужных зависимостей.
5. `D — Dependency Inversion Principle (Принцип инверсии зависимостей)`
	**Суть**: Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций (например, интерфейсов). Абстракции не должны зависеть от деталей реализации.
	**Почему важно**: Это снижает связанность и упрощает замену компонентов (например, замену базы данных без изменения бизнес-логики).
	**Применение**: Используйте Dependency Injection (внедрение зависимостей) или абстрактные классы для связи компонентов.


Ernest, [25-Jun-25 11:12]
1. Single Responsibility Principle (SRP)
Каждый модуль или класс должен отвечать только за одну часть функциональности. Изменения в одной части требований должны приводить к изменениям только в одном модуле.

2. Open/Closed Principle (OCP)
Модули должны быть открыты для расширения, но закрыты для модификации. Новое поведение нужно добавлять, не изменяя существующий код.

3. Liskov Substitution Principle (LSP)
Объекты дочернего класса должны заменять объекты родительского класса без нарушения логики программы. Поведение должно оставаться предсказуемым.

4. Interface Segregation Principle (ISP)
Лучше много специализированных интерфейсов, чем один универсальный. Пользователь интерфейса не должен зависеть от методов, которые он не использует.

5. Dependency Inversion Principle (DIP)
Зависимости должны быть абстрактными, а не от конкретных реализаций. Высокоуровневые модули не должны зависеть от низкоуровневых напрямую.

Ernest, [25-Jun-25 11:13]
1. Принцип единственной ответственности (SRP)
Класс или модуль должен иметь только одну причину для изменения — то есть отвечать только за одну задачу в системе.

2. Принцип открытости/закрытости (OCP)
Код должен быть открыт для расширения, но закрыт для изменения. Поведение системы расширяется через новые сущности, а не правкой существующих.

3. Принцип подстановки Барбары Лисков (LSP)
Дочерние классы должны полноценно заменять родительские. Если где-то используется родитель, его можно безопасно заменить наследником — и программа будет работать корректно.

4. Принцип разделения интерфейса (ISP)
Лучше иметь много маленьких, специализированных интерфейсов, чем один общий. Класс не должен зависеть от методов, которые он не использует.

5. Принцип инверсии зависимостей (DIP)
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа должны зависеть от абстракций. Абстракции не должны зависеть от деталей, детали дол